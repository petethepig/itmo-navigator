// Generated by CoffeeScript 1.6.2
var DirectionView, Graph, MainView, SearchResultView;

DirectionView = Backbone.View.extend({
  initialize: function() {
    this.$el = $("<div class='direction' ><div class='icon' ></div><div class='length'></div><div class='label'></div></div>");
    return this.el = this.$el.get(0);
  },
  render: function() {
    if (this.model) {
      this.$el.children(".icon").addClass(this.model.icon);
      if (this.model.length) {
        this.$el.children(".length").text(Math.round(this.model.length / 1042 * 153) + " м");
      }
      this.$el.show().children(".label").text(this.model.name);
    } else {
      this.$el.hide();
    }
    return this;
  }
});

SearchResultView = Backbone.View.extend({
  initialize: function() {
    this.$el = $("<a href='javascript:void(0);' class='search-result' ></a>");
    return this.el = this.$el.get(0);
  },
  initEvents: function() {
    var clickHandler, that;

    that = this;
    clickHandler = function(e) {
      e.preventDefault();
      that.trigger("click", that);
      return $("#from>input, #to>input").blur();
    };
    return Hammer(this.el).on("tap", clickHandler);
  },
  update: function() {
    if (this.model) {
      return this.$el.show().html(this.model.string);
    } else {
      return this.$el.hide();
    }
  }
});

MainView = Backbone.View.extend({
  matches: [],
  locations: {
    from: null,
    to: null
  },
  criteries: {
    from: "",
    to: ""
  },
  focused: null,
  searchResultViews: [],
  directionViews: [],
  fuzzy_options: {
    pre: '<strong>',
    post: '</strong>',
    extract: function(e) {
      return e.name;
    }
  },
  initialize: function() {
    var i, view, _i;

    Hammer($(".clear-btn").get(0)).on("tap", this.clearHandler.bind(this));
    for (i = _i = 0; _i < 20; i = _i += 1) {
      view = new SearchResultView();
      $("#search-results").append(view.$el);
      view.initEvents();
      view.on("click", this.clickHandler.bind(this));
      this.searchResultViews[i] = view;
    }
    return this.update();
  },
  clickHandler: function(view) {
    this.locations[this.focused] = view.model.original;
    $("#" + this.focused + ">input").val(view.model.original.name);
    this.focused = null;
    $(".input-wrapper").removeClass("expand fade-out");
    $(".clear-btn").removeClass("fade-in");
    return this.update();
  },
  events: {
    "focus #from>input, #to>input": "focusHandler",
    "blur #from>input, #to>input": "blurHandler",
    "keyup #from>input, #to>input": "keypressHandler"
  },
  focusHandler: function(e) {
    var $p, id, pairs;

    e.target.value = "";
    pairs = {
      "from": "#to",
      "to": "#from"
    };
    $p = $(e.target).parent();
    id = $p.attr("id");
    $p.addClass("expand");
    $(pairs[id]).addClass("fade-out");
    $(".clear-btn").addClass("fade-in");
    this.focused = id;
    return this.update();
  },
  clearHandler: function(e) {
    var $el;

    console.log(this.focused);
    if (this.focused) {
      $el = $("#" + this.focused + ">input").val("").focus();
      this.criteries[this.focused] = "";
      this.update();
      return $el.focus();
    }
  },
  blurHandler: function(e) {},
  keypressHandler: function(e) {
    var that;

    that = this;
    return setTimeout(function() {
      return that.update();
    }, 1);
  },
  update: function() {
    var direction, i, match, prev_direction, results, route, that, view, _i, _j, _len, _len1, _ref, _results;

    this.criteries[this.focused] = $("#" + this.focused + ">input").val();
    $("#search-results").toggle(this.focused !== null);
    $("#directions").toggle((this.focused === null) && !!this.locations.from && !!this.locations.to);
    that = this;
    results = fuzzy.filter(this.criteries[this.focused] || "", this.model.locations, this.fuzzy_options);
    this.matches = results.map(function(el) {
      return el;
    });
    $(".nothing-found").toggle(this.matches.length <= 0);
    i = 0;
    _ref = this.searchResultViews;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      view = _ref[_i];
      match = this.matches[i];
      view.model = match;
      view.update();
      i++;
    }
    this;
    if (!!this.locations.from && !!this.locations.to) {
      route = this.model.getRoute(this.locations.from, this.locations.to);
      console.log(route);
      $("#directions").empty();
      if (route.length > 0) {
        prev_direction = null;
        _results = [];
        for (_j = 0, _len1 = route.length; _j < _len1; _j++) {
          direction = route[_j];
          view = new DirectionView({
            model: direction
          });
          $("#directions").append(view.el);
          view.render();
          _results.push(prev_direction = direction);
        }
        return _results;
      } else {
        return $("#directions").append($("<div class='nothing-found'>Путь не найден</div>"));
      }
    }
  }
});

Graph = function(data) {
  var connect, edge, iconFor, lengthFor, locations, locationsForId, opposite, relativesFor, vertices, _getRoute, _i, _len, _ref;

  locationsForId = {};
  relativesFor = {};
  lengthFor = {};
  iconFor = {};
  opposite = {
    "R": "L",
    "L": "R",
    "A": "A"
  };
  connect = function(a, b, c) {
    var x, y;

    relativesFor[a] || (relativesFor[a] = []);
    relativesFor[b] || (relativesFor[b] = []);
    relativesFor[a].push(b);
    relativesFor[b].push(a);
    x = vertices[a].x - vertices[b].x;
    y = (vertices[a].y - vertices[b].y) * 2;
    lengthFor[a + b] = lengthFor[b + a] = Math.sqrt(x * x + y * y);
    iconFor[a + b] = c || "A";
    return iconFor[b + a] = opposite[iconFor[a + b]];
  };
  vertices = data.vertices;
  locations = data.locations;
  _ref = data.edges;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    edge = _ref[_i];
    connect.apply(this, edge);
  }
  _(locations).each(function(l) {
    var _name;

    locationsForId[_name = l.at] || (locationsForId[_name] = []);
    return locationsForId[l.at].push(l);
  });
  window.lengthFor = lengthFor;
  _getRoute = function(from_loc, to_loc) {
    var checked, currentLocation, from, i, index, l, lengths, prev_location, queue, relations, relative, result, tmpLoc, to, _j, _len1, _ref1;

    from = from_loc.at;
    to = to_loc.at;
    queue = [from];
    checked = [];
    relations = {};
    result = [];
    lengths = {};
    lengths[from] = 0;
    while (queue.length > 0) {
      currentLocation = queue.shift();
      checked.push(currentLocation);
      if (to === currentLocation) {
        tmpLoc = to;
        while (tmpLoc) {
          result.unshift(tmpLoc);
          tmpLoc = relations[tmpLoc];
        }
        break;
      }
      if (relativesFor[currentLocation]) {
        _ref1 = relativesFor[currentLocation];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          relative = _ref1[_j];
          if (!_.contains(checked, relative)) {
            l = lengths[currentLocation] + lengthFor[currentLocation + relative];
            if (!relations[relations] || relations[relative] > l) {
              relations[relative] = currentLocation;
              l = lengths[relative] = lengths[currentLocation] + lengthFor[currentLocation + relative];
              index = 0;
              for (i in queue) {
                if (l > lengths[queue[i]]) {
                  index = i + 1;
                } else {
                  break;
                }
              }
              if (!_.contains(queue, relative)) {
                queue.splice(index, 0, relative);
              }
            }
          }
        }
      }
    }
    prev_location = null;
    result = result.map(function(id) {
      var length, location, parent;

      parent = relations[id];
      location = locationsForId[id][0];
      length = lengthFor[parent + id];
      prev_location = location;
      return {
        icon: iconFor[parent + id],
        name: location.name,
        length: length
      };
    });
    if (result.length > 0) {
      result[0].name = from_loc.name;
      result[result.length - 1].name = to_loc.name;
      result[0].icon = "S";
      result[result.length - 1].icon += " F";
    }
    return result;
  };
  return {
    locations: locations,
    getRoute: _getRoute
  };
};

$(function() {
  return $.ajax({
    url: "./data.json",
    success: function(data) {
      var graph, mainView;

      graph = new Graph(data);
      $("header").show();
      mainView = new MainView({
        el: $("#wrapper"),
        model: graph
      });
      return graph.getRoute(graph.locations[0], graph.locations[15]);
    }
  });
});
